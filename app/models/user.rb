class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable
  has_many :projects
  acts_as_taggable_on :skills
  acts_as_taggable_on :interests
  acts_as_tagger
  mount_uploader :profile_pic, ProfilePicUploader

  validate :at_least_2_skills
  validate :at_least_2_interests

  validates :username,
    presence: true,
    length: { minimum: 3, maximum: 15},
    uniqueness: true

  validates :first_name,
    presence: true,
    length: { maximum: 25 }

  validates :last_name,
    presence: true,
    length: { maximum: 25 }

  validates :about_me,
    presence: true,
    length: { minimum: 20 }

  validates :email,
    presence: true

  # make test for phone, zip, and profile pic
  def at_least_2_skills
    if skill_list.count >= 2
      true
    else
      errors.messages[:skill_error] = ["not enough skills"]
      false
    end
  end

  def at_least_2_interests
    # if we return false in a callback the record will not be saved
    if interest_list.count >= 2
      true
    else
      errors.messages[:interest_error] = ["not enough interests"] # change error message appropriately
      false
    end
  end

  def project_matches(project)
    matches = Array.new
    (project.skill_list & self.skill_list).each do |match|
      matches << { "skill" => match }
    end
    (project.interest_list & self.interest_list).each do |match|
      matches << { "interest" => match }
    end
    matches
  end

  def recommended_projects
    ideal_project = projects.create(
      name: "ideal project",
      proposal: "This is an ideal project generated by the user's skills and
      interests and temporarily used for the purpose of finding releated
      projects",
      skill_list: skill_list.join(", "),
      interest_list: interest_list.join(", "))

    ideal_skills = ideal_project.skill_list
    ideal_interests = ideal_project.interest_list
    recommended_projects_by_interests = ideal_project.find_related_interests
    recommended_projects_by_skills = ideal_project.find_related_skills
    recommended_projects = recommended_projects_by_skills +
      recommended_projects_by_interests
    recommended_projects.uniq!

    scored_projects = Hash.new
    Project.destroy(ideal_project.id)

    recommended_projects.each do |proj|
      unless proj.user.id == self.id
        # i don't want to be recommended one of my own projects
        skill_intersection = ideal_skills & proj.skill_list
        interest_intersection = ideal_interests & proj.interest_list
        if skill_intersection.any? && interest_intersection.any?
          score = 5
          # if they have a match on both skills and interests that should
          # have a higher recommendation value
          score = score + skill_intersection.count + interest_intersection.count
          scored_projects[proj] = score
        elsif skill_intersection.any?
          score = skill_intersection.count
          scored_projects[proj] = score
        else
          score = interest_intersection.count
          scored_projects[proj] = score
        end
      end
    end
    scored_projects = scored_projects.sort_by { |_proj, score| score }.reverse
    top_5_recommended_projects = scored_projects[0..4]
    top_5_recommended_projects.to_h.keys
  end
end
